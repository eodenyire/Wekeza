using Wekeza.Nexus.Domain.Enums;

namespace Wekeza.Nexus.Domain.ValueObjects;

/// <summary>
/// Value object representing the fraud score and decision
/// Inspired by BioCatch, Feedzai, and RembrandtAi scoring systems
/// </summary>
public record FraudScore
{
    /// <summary>
    /// Fraud risk score from 0 (no risk) to 1000 (maximum risk)
    /// </summary>
    public int Score { get; init; }
    
    /// <summary>
    /// Risk level classification
    /// </summary>
    public RiskLevel RiskLevel { get; init; }
    
    /// <summary>
    /// The decision to take on this transaction
    /// </summary>
    public FraudDecision Decision { get; init; }
    
    /// <summary>
    /// Primary reason for the fraud flag
    /// </summary>
    public FraudReason PrimaryReason { get; init; }
    
    /// <summary>
    /// Additional contributing reasons
    /// </summary>
    public List<FraudReason> ContributingReasons { get; init; } = new();
    
    /// <summary>
    /// Human-readable explanation of the decision
    /// Generated by the AI explanation engine
    /// </summary>
    public string Explanation { get; init; } = string.Empty;
    
    /// <summary>
    /// Confidence level of the fraud detection (0.0 to 1.0)
    /// </summary>
    public double Confidence { get; init; }
    
    private FraudScore() { }
    
    /// <summary>
    /// Creates a fraud score with automatic risk level and decision mapping
    /// </summary>
    public static FraudScore Create(
        int score, 
        FraudReason primaryReason, 
        List<FraudReason>? contributingReasons = null,
        string explanation = "",
        double confidence = 1.0)
    {
        if (score < 0 || score > 1000)
            throw new ArgumentException("Score must be between 0 and 1000", nameof(score));
        
        if (confidence < 0 || confidence > 1.0)
            throw new ArgumentException("Confidence must be between 0.0 and 1.0", nameof(confidence));
        
        var riskLevel = DetermineRiskLevel(score);
        var decision = DetermineDecision(score, riskLevel);
        
        return new FraudScore
        {
            Score = score,
            RiskLevel = riskLevel,
            Decision = decision,
            PrimaryReason = primaryReason,
            ContributingReasons = contributingReasons ?? new List<FraudReason>(),
            Explanation = explanation,
            Confidence = confidence
        };
    }
    
    private static RiskLevel DetermineRiskLevel(int score)
    {
        return score switch
        {
            <= 200 => RiskLevel.VeryLow,
            <= 400 => RiskLevel.Low,
            <= 600 => RiskLevel.Medium,
            <= 800 => RiskLevel.High,
            _ => RiskLevel.Critical
        };
    }
    
    private static FraudDecision DetermineDecision(int score, RiskLevel riskLevel)
    {
        return score switch
        {
            <= 400 => FraudDecision.Allow,
            <= 700 => FraudDecision.Challenge,
            <= 850 => FraudDecision.Review,
            _ => FraudDecision.Block
        };
    }
    
    /// <summary>
    /// Creates a safe transaction score (no fraud detected)
    /// </summary>
    public static FraudScore Safe() => Create(0, FraudReason.None, explanation: "Transaction appears normal with no risk indicators.");
}
