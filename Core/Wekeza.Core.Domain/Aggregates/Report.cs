using Wekeza.Core.Domain.Common;
using Wekeza.Core.Domain.Enums;
using Wekeza.Core.Domain.Events;

namespace Wekeza.Core.Domain.Aggregates;

/// <summary>
/// Report Aggregate - Manages report generation, storage, and submission
/// Supports financial, regulatory, operational, and analytical reports
/// Industry Standard: Finacle MIS & T24 Information Reporting
/// </summary>
public class Report : AggregateRoot
{
    // Core Properties
    public string ReportCode { get; private set; }
    public string ReportName { get; private set; }
    public ReportType ReportType { get; private set; }
    public ReportCategory Category { get; private set; }
    public ReportStatus Status { get; private set; }
    
    // Generation Details
    public DateTime GeneratedAt { get; private set; }
    public string GeneratedBy { get; private set; }
    public DateTime ReportingPeriodStart { get; private set; }
    public DateTime ReportingPeriodEnd { get; private set; }
    
    // Content & Format
    public string ReportData { get; private set; } // JSON/XML data
    public ReportFormat Format { get; private set; }
    public string FilePath { get; private set; }
    public long FileSizeBytes { get; private set; }
    
    // Metadata
    public Dictionary<string, object> Parameters { get; private set; }
    public Dictionary<string, object> Metadata { get; private set; }
    
    // Audit & Compliance
    public bool IsRegulatory { get; private set; }
    public string RegulatoryReference { get; private set; }
    public DateTime? SubmittedAt { get; private set; }
    public string SubmittedBy { get; private set; }
    
    // Archival
    public DateTime? ArchivedAt { get; private set; }
    public string ArchiveLocation { get; private set; }
    public bool IsArchived { get; private set; }

    // Private constructor for EF Core
    private Report() : base(Guid.NewGuid()) {
        Parameters = new Dictionary<string, object>();
        Metadata = new Dictionary<string, object>();
    }

    // Factory method for creating new reports
    public static Report Create(
        string reportCode,
        string reportName,
        ReportType reportType,
        ReportCategory category,
        DateTime periodStart,
        DateTime periodEnd,
        string generatedBy,
        Dictionary<string, object> parameters = null,
        bool isRegulatory = false,
        string regulatoryReference = null)
    {
        // Validation
        if (string.IsNullOrWhiteSpace(reportCode))
            throw new ArgumentException("Report code cannot be empty", nameof(reportCode));
        
        if (string.IsNullOrWhiteSpace(reportName))
            throw new ArgumentException("Report name cannot be empty", nameof(reportName));
        
        if (string.IsNullOrWhiteSpace(generatedBy))
            throw new ArgumentException("Generated by cannot be empty", nameof(generatedBy));
        
        if (periodStart >= periodEnd)
            throw new ArgumentException("Period start must be before period end");

        var report = new Report
        {
            Id = Guid.NewGuid(),
            ReportCode = reportCode,
            ReportName = reportName,
            ReportType = reportType,
            Category = category,
            Status = ReportStatus.Pending,
            GeneratedAt = DateTime.UtcNow,
            GeneratedBy = generatedBy,
            ReportingPeriodStart = periodStart,
            ReportingPeriodEnd = periodEnd,
            Parameters = parameters ?? new Dictionary<string, object>(),
            Metadata = new Dictionary<string, object>(),
            IsRegulatory = isRegulatory,
            RegulatoryReference = regulatoryReference,
            IsArchived = false
        };

        // Add creation event
        report.AddDomainEvent(new ReportCreatedDomainEvent(
            report.Id,
            report.ReportCode,
            report.ReportType,
            report.Category,
            report.GeneratedBy,
            report.IsRegulatory));

        return report;
    }

    // Generate report with data and format
    public void GenerateReport(string reportData, ReportFormat format, string filePath = null, long fileSizeBytes = 0)
    {
        if (Status != ReportStatus.Pending)
            throw new InvalidOperationException($"Cannot generate report in status: {Status}");

        if (string.IsNullOrWhiteSpace(reportData))
            throw new ArgumentException("Report data cannot be empty", nameof(reportData));

        ReportData = reportData;
        Format = format;
        FilePath = filePath;
        FileSizeBytes = fileSizeBytes;
        Status = ReportStatus.Generated;

        // Update metadata
        Metadata["GenerationCompletedAt"] = DateTime.UtcNow;
        Metadata["DataSize"] = reportData.Length;
        Metadata["Format"] = format.ToString();

        AddDomainEvent(new ReportGeneratedDomainEvent(
            Id,
            ReportCode,
            ReportType,
            Format,
            FileSizeBytes));
    }

    // Submit report to regulatory authority
    public void SubmitToRegulator(string submittedBy)
    {
        if (!IsRegulatory)
            throw new InvalidOperationException("Cannot submit non-regulatory report");

        if (Status != ReportStatus.Generated)
            throw new InvalidOperationException($"Cannot submit report in status: {Status}");

        if (string.IsNullOrWhiteSpace(submittedBy))
            throw new ArgumentException("Submitted by cannot be empty", nameof(submittedBy));

        SubmittedAt = DateTime.UtcNow;
        SubmittedBy = submittedBy;
        Status = ReportStatus.Submitted;

        // Update metadata
        Metadata["SubmissionCompletedAt"] = DateTime.UtcNow;
        Metadata["SubmittedBy"] = submittedBy;

        AddDomainEvent(new ReportSubmittedDomainEvent(
            Id,
            ReportCode,
            RegulatoryReference,
            SubmittedBy,
            SubmittedAt.Value));
    }

    // Archive report for long-term storage
    public void ArchiveReport(string archiveLocation = null)
    {
        if (Status == ReportStatus.Pending)
            throw new InvalidOperationException("Cannot archive pending report");

        if (IsArchived)
            throw new InvalidOperationException("Report is already archived");

        ArchivedAt = DateTime.UtcNow;
        ArchiveLocation = archiveLocation ?? $"archive/{ReportCode}_{GeneratedAt:yyyyMMdd}";
        IsArchived = true;
        Status = ReportStatus.Archived;

        // Update metadata
        Metadata["ArchivedAt"] = ArchivedAt;
        Metadata["ArchiveLocation"] = ArchiveLocation;

        AddDomainEvent(new ReportArchivedDomainEvent(
            Id,
            ReportCode,
            ArchiveLocation,
            ArchivedAt.Value));
    }

    // Regenerate report with new parameters
    public void RegenerateReport(Dictionary<string, object> newParameters, string regeneratedBy)
    {
        if (string.IsNullOrWhiteSpace(regeneratedBy))
            throw new ArgumentException("Regenerated by cannot be empty", nameof(regeneratedBy));

        // Reset status and clear previous data
        Status = ReportStatus.Pending;
        ReportData = null;
        FilePath = null;
        FileSizeBytes = 0;
        
        // Update parameters and metadata
        Parameters = newParameters ?? new Dictionary<string, object>();
        Metadata["RegeneratedAt"] = DateTime.UtcNow;
        Metadata["RegeneratedBy"] = regeneratedBy;
        Metadata["RegenerationCount"] = Metadata.ContainsKey("RegenerationCount") 
            ? (int)Metadata["RegenerationCount"] + 1 
            : 1;

        AddDomainEvent(new ReportRegeneratedDomainEvent(
            Id,
            ReportCode,
            regeneratedBy,
            DateTime.UtcNow));
    }

    // Mark report as failed
    public void MarkAsFailed(string errorMessage, string failedBy)
    {
        if (string.IsNullOrWhiteSpace(errorMessage))
            throw new ArgumentException("Error message cannot be empty", nameof(errorMessage));

        Status = ReportStatus.Failed;
        
        // Update metadata with error information
        Metadata["FailedAt"] = DateTime.UtcNow;
        Metadata["FailedBy"] = failedBy;
        Metadata["ErrorMessage"] = errorMessage;

        AddDomainEvent(new ReportFailedDomainEvent(
            Id,
            ReportCode,
            errorMessage,
            failedBy,
            DateTime.UtcNow));
    }

    // Add parameter
    public void AddParameter(string key, object value)
    {
        if (string.IsNullOrWhiteSpace(key))
            throw new ArgumentException("Parameter key cannot be empty", nameof(key));

        Parameters[key] = value;
    }

    // Add metadata
    public void AddMetadata(string key, object value)
    {
        if (string.IsNullOrWhiteSpace(key))
            throw new ArgumentException("Metadata key cannot be empty", nameof(key));

        Metadata[key] = value;
    }

    // Get parameter value
    public T GetParameter<T>(string key, T defaultValue = default)
    {
        if (Parameters.ContainsKey(key) && Parameters[key] is T value)
            return value;
        
        return defaultValue;
    }

    // Get metadata value
    public T GetMetadata<T>(string key, T defaultValue = default)
    {
        if (Metadata.ContainsKey(key) && Metadata[key] is T value)
            return value;
        
        return defaultValue;
    }

    // Check if report is overdue (for regulatory reports)
    public bool IsOverdue(DateTime currentDate)
    {
        if (!IsRegulatory || Status == ReportStatus.Submitted)
            return false;

        // Regulatory reports are typically due within 30 days of period end
        var dueDate = ReportingPeriodEnd.AddDays(30);
        return currentDate > dueDate;
    }

    // Calculate report age in days
    public int GetAgeInDays(DateTime currentDate)
    {
        return (currentDate.Date - GeneratedAt.Date).Days;
    }

    // Check if report needs regeneration (based on data freshness)
    public bool NeedsRegeneration(DateTime currentDate, int maxAgeInDays = 7)
    {
        if (Status != ReportStatus.Generated)
            return false;

        return GetAgeInDays(currentDate) > maxAgeInDays;
    }
}


